schema {
  query: Query
  mutation: Mutation
}

type ValidationResult {
  isValid: Boolean!
  errors: [ValidationFailure]
}

type ValidationFailure {
  propertyName: String
  errorMessage: String
  severity: Severity!
  errorCode: String
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
  eqInvariant: String
  containsInvariant: String
}

type Query {
  clusters(skip: Int take: Int where: ClusterResourceFilterInput order: [ClusterResourceSortInput!]): ClustersCollectionSegment
  clusterById(id: UUID!): ClusterResource!
}

type Mutation {
  createCluster(input: CreateClusterInput!): CreateClusterPayload!
  validateCreateCluster(input: ValidateCreateClusterInput!): ValidateCreateClusterPayload!
  updateCluster(input: UpdateClusterInput!): UpdateClusterPayload!
  validateUpdateCluster(input: ValidateUpdateClusterInput!): ValidateUpdateClusterPayload!
  deleteCluster(input: DeleteClusterInput!): DeleteClusterPayload!
}

enum Severity {
  ERROR
  WARNING
  INFO
}

input ClusterResourceFilterInput {
  and: [ClusterResourceFilterInput!]
  or: [ClusterResourceFilterInput!]
  id: UuidOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  updatedAt: DateTimeOperationFilterInput
  version: StringOperationFilterInput
  serverName: StringOperationFilterInput
  serverAddress: StringOperationFilterInput
  serverCertificateAuthorityData: StringOperationFilterInput
  userName: StringOperationFilterInput
  userCredentialsCertificateData: StringOperationFilterInput
  userCredentialsKeyData: StringOperationFilterInput
  namespace: StringOperationFilterInput
}

input ClusterResourceSortInput {
  id: SortEnumType
  createdAt: SortEnumType
  updatedAt: SortEnumType
  version: SortEnumType
  serverName: SortEnumType
  serverAddress: SortEnumType
  serverCertificateAuthorityData: SortEnumType
  userName: SortEnumType
  userCredentialsCertificateData: SortEnumType
  userCredentialsKeyData: SortEnumType
  namespace: SortEnumType
}

"A segment of a collection."
type ClustersCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [ClusterResource!]
  totalCount: Int!
}

type ValidationError implements Error {
  message: String!
  errors: [ValidationFailure]
}

input UuidOperationFilterInput {
  eq: UUID
  neq: UUID
  in: [UUID]
  nin: [UUID]
  gt: UUID
  ngt: UUID
  gte: UUID
  ngte: UUID
  lt: UUID
  nlt: UUID
  lte: UUID
  nlte: UUID
}

input DateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

enum SortEnumType {
  ASC
  DESC
}

"Information about the offset pagination."
type CollectionSegmentInfo {
  "Indicates whether more items exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more items exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
}

type ClusterResource {
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: String!
  serverName: String!
  serverAddress: String!
  serverCertificateAuthorityData: String!
  userName: String!
  userCredentialsCertificateData: String!
  userCredentialsKeyData: String!
  namespace: String!
  status: ClusterStatus
}

interface Error {
  message: String!
}

scalar UUID

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

type ClusterStatus {
  isOperative: Boolean!
  nodes: [NodeInfo!]!
}

input ClusterDataInput {
  serverName: String!
  serverAddress: String!
  serverCertificateAuthorityData: String!
  userName: String!
  userCredentialsCertificateData: String!
  userCredentialsKeyData: String!
  namespace: String!
}

type NodeInfo {
  id: UUID!
  name: String!
  ipAddresses: [String!]!
  roles: [String!]!
  conditions: [NodeCondition!]!
  architecture: String
  bootID: String
  containerRuntimeVersion: String
  kernelVersion: String
  kubeProxyVersion: String
  kubeletVersion: String
  machineID: String
  operatingSystem: String
  osImage: String
  systemUUID: String
  podCIDR: String
  podCIDRs: [String!]!
}

type NodeCondition {
  type: String!
  isOperative: Boolean!
  message: String
}

input CreateClusterInput {
  data: ClusterDataInput!
}

union CreateClusterError = ValidationError

type CreateClusterPayload {
  clusterResource: ClusterResource
  errors: [CreateClusterError!]
}

input ValidateCreateClusterInput {
  data: ClusterDataInput!
}

type ValidateCreateClusterPayload {
  validationResult: ValidationResult
}

input UpdateClusterInput {
  clusterId: UUID!
  data: ClusterDataInput!
  version: String!
}

union UpdateClusterError = ValidationError

type UpdateClusterPayload {
  clusterResource: ClusterResource
  errors: [UpdateClusterError!]
}

input ValidateUpdateClusterInput {
  clusterId: UUID!
  data: ClusterDataInput!
}

type ValidateUpdateClusterPayload {
  validationResult: ValidationResult
}

input DeleteClusterInput {
  clusterId: UUID!
}

type DeleteClusterPayload {
  clusterResource: ClusterResource
}